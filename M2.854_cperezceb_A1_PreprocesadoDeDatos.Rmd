---
title: 'Estadística Avanzada:  A1 - Preprocesado de Datos'
author: "cperezceb - Carlos Pérez Cebrián"
date: "Marzo 2022"
output:
  html_document:
    highlight: default
    number_sections: no
    theme: cosmo
    toc: yes
    toc_depth: 2
  word_document: default
  pdf_document:
    highlight: zenburn
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
******
# A1 - Preprocesado de Datos
******
En esta actividad realizaremos el preprocesado de un fichero de datos que contiene información de una muestra
extraída a partir de un censo, en el que para cada persona, se registran los salarios aparte de información
personal adicional. El conjunto de datos contiene 32,560 registros y 14 variables. Los datos se han extraído y
modificado parcialmente (por motivos académicos) de la base de datos disponible en la web Machine Learning
Repository: https://archive.ics.uci.edu/ml/datasets/Adult.

## Cargar el archivo
Cargar el archivo de datos y examinar el tipo de datos con los que R ha interpretado cada variable. Examinar
también los valores resumen de cada tipo de variable.

***
Instalamos y cargamos la librerias.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# https://cran.r-project.org/web/packages/ggplot2/index.html
if (!require('ggplot2')) install.packages('ggplot2'); library('ggplot2')
# https://cran.r-project.org/web/packages/dplyr/index.html
if (!require('dplyr')) install.packages('dplyr'); library('dplyr')
# https://cran.r-project.org/web/packages/dplyr/index.html
if (!require('tidyverse')) install.packages('tidyverse'); library('tidyverse')
# https://cran.rstudio.com/bin/windows/contrib/4.0/gridExtra_2.3.zip
if (!require('gridExtra')) install.packages('gridExtra'); library(gridExtra)

```

Cargamos en la variable _DatosCenso_ el fichero proporcionado .

```{r}
DatosCenso <- read.csv2(file="CensusIncomedataset.csv", header=TRUE, sep=";", dec=".", stringsAsFactors = FALSE);
```

Revisamos su estructura.

* Tamaño de la muestra.
* Número de variables disponibles
* Tipo de datos (texto, numérico, fecha)

```{r}
str(DatosCenso)
```

Veamos una pequeña muestra del conjunto de datos a estudio.

```{r}
head(DatosCenso,6)
```

* Datos de la muestra:
  + **CS_ID**: Identificador del individuo.
  + **age**: Edad del individuo.
  + **workclass**: Categorización del individuo en base al perfil laboral.
  + **fnlwgt**: Numero de unidades de la población objetivo que representa la unidad respondiente.
  + **education_num**: Numero de años de formación educativa del individuo.
  + **marital_status**: Estado civil del individuo.
  + **occupation**: Categorización del individuo en base a la tipologia del trabajo.
  + **relationship**: Parentesco de la unidad que responde de la familia.
  + **race**: Grupo racial al que pertenece el individuo.
  + **sex**: Genero del individuo.
  + **capital_gain**: Dineros ganados por inversión del individuo.
  + **capital_loss**: Dineros perdidos por inversión del individuo.
  + **hours_per_week**: Horas por semana trabajadas por el individuo.
  + **income**: Salario (anual) del individuo.

 
Sacamos algunas estadísticas sobre los datos para hacernos una idea de cómo son.

```{r}
print(summary(DatosCenso))
```

## Obtención del dataset para realizar el estudio
En esta fase se seleccionan los registros y/o variables que se utilizarán para realizar el estudio. En muchas
ocasiones, no se trabaja con todo el dataset disponible ya que existen variables y/o registros de control o que
no es necesario usar para el estudio concreto que se quiere realizar.

En este caso, se quieren eliminar las variables fnlwgt, capital_gain y capital_loss además de los registros
con más de 5 valores NAs.

Por otra parte, se pueden crear nuevas variables en función de las disponibles. En este caso, se creará la
variable education_cat que categoriza la formación académica en formación primaria si education_num
es menor de 7 años, secundaria si education_num está entre 7 y 9 años, universitaria si education_num
esta entre 10 y 13 años y postuniversitaria si education_num es mayor de 13 años.

Por último, se quiere cambiar el nombre de la variable sex por gender.

***

Descartamos las variables _fnlwgt, capital_gain y capital_loss_ que no son objeto de estudio

```{r}
DatosCenso$fnlwgt <- NULL
DatosCenso$capital_gain <- NULL
DatosCenso$capital_loss <- NULL
```

Revisamos los episodios con valores nulos y eliminamos los registros con 5 valores NAs

```{r}

DescartarValoresNa <- function(Datos, n=0) {
  Datos[rowSums(is.na(Datos)) <= n,]
}

DatosCenso <- DescartarValoresNa(DatosCenso,5)
```

Tras estas operaciones sobre nuestro conjunto de datos, la variable _DatosCenso_ queda de la siguiente forma:

```{r echo=FALSE}
print( paste0("Tamaño de la muestra es: ", dim(DatosCenso)[1], " y contiene ",dim(DatosCenso)[2]," variables."))
#print( paste0("Número de variables: ", dim(DatosCenso)[2]))

```

Creamos la variable _education_cat_ que identificará el nivel de estudios y puede tener los siguientes valores:

* primaria, estudios inferiores a 7 años
* secundaria, estudios comprendidos entre 7 y 9 años
* universitaria, estudios comprendidos entre 10 y 13 años.
* postuniversitaria, estudios de más de 13 años.

```{r}
# Valor por defecto
DatosCenso$education_cat<-'primaria' 
DatosCenso$education_cat<- cut(DatosCenso$education_num, breaks=c(0,6,9,13,100),labels=c('primaria','secundaria','universitaria','postuniversitaria'))

# Representamos gráficamente los valores de la nueva variable
plot(DatosCenso$education_cat)

```

Por último, cambiamos el nombre de la variable _sex_ por _gender_.

```{r}
names(DatosCenso)[names(DatosCenso)=='sex']<-'gender'
```

Revisamos los datos de la variable de _gender_
```{r}
table(DatosCenso$gender)
```

## Duplicación de códigos
Verificad la consistencia en la variable CS_ID. Si existen registros duplicados, asignad un nuevo código para
evitar códigos duplicados. El nuevo código debe ser un valor no usado (valores superiores al máximo valor numérico contenido en CS_ID). Conservad el mismo formato que el resto de códigos, con “CS” delante de la
secuencia numérica. Podéis usar la función duplicated de R para detectar los duplicados.

***

Comprobamos, para la variabla _CS_ID_, cuantos valores únicos tiene y comparamos con el total de registros.

```{r}
#Obtener los valores repetidos para la variable CS_ID
duplicados <- unique(DatosCenso[duplicated(DatosCenso$CS_ID, fromLast=TRUE),])
table(duplicados$CS_ID)

#Obtener el valor máximo para generar los nuevos índices.
indices<-gsub("CS","",DatosCenso$CS_ID)
indice_max <- max(as.numeric(indices))


#actualizar los identificadores duplicados con los nuevos valores.
for(i in 1:dim(duplicados)[1])
{
    indice_max<- indice_max+1
    indice_next <- paste0('CS',indice_max)
    
    row_index<- which.max(DatosCenso$CS_ID==duplicados[i,]$CS_ID)
    DatosCenso[row_index,]$CS_ID<-indice_next
}

#Comprobación: Obtener los valores repetidos para la variable CS_ID
duplicados <- unique(DatosCenso[duplicated(DatosCenso$CS_ID, fromLast=TRUE),])
table(duplicados$CS_ID)

```

## Normalización de los datos cualitativos

***

### Eliminación de espacios en blanco
Se ha observado que existen espacios en blanco al inicio de los valores en las variables cualitativas. Por tanto,
es necesario eliminar estos espacios en blancos.

*** 

Utilizaremos la función _trimws_ para limpiar los espacios en blanco de las variables categóricas.

```{r}

for(i in colnames(DatosCenso)) 
{ 
  if(class(DatosCenso[[i]])=="character")
  {
    DatosCenso[[i]]<-trimws(DatosCenso[[i]], which=c("both", "left", "right"))
    # print(paste0("Columna: ", i , " Tipo de la columna: ", class(DatosCenso[[i]]) ))
  }
}

```


### Marital-Status
Cambiar las categorías de la variable marital status actuales por otras que ocupen un carácter. Los valores
que se asignaron a la variable marital_status son: M por Married, S por Single, X por Separated, D por
Divorced, W por Widowed. Representad gráficamente la distribución de los valores de la variable.

```{r echo=TRUE, warning=TRUE, error=TRUE}

DatosCenso$marital_status[DatosCenso$marital_status == "Married"]  <- "M"

DatosCenso$marital_status[DatosCenso$marital_status == "Single"]   <- "S"

DatosCenso$marital_status[DatosCenso$marital_status =="Separated"] <- "X"

DatosCenso$marital_status[DatosCenso$marital_status =="Divorced"]  <- "D"

DatosCenso$marital_status[DatosCenso$marital_status =="Widowed"]   <- "W"


ggplot(DatosCenso, aes(x=marital_status)) + geom_bar(fill="palegreen") + labs(x="Marital-Status")

table(DatosCenso$marital_status)


```


### Género
Revisad la consistencia de los valores de la variable gender y realice las modificaciones oportunas para indicar
las categorías finales como f y m que corresponde a femeníno y masculíno, respectivamente. 

Representad gráficamente la distribución de los valores de la variable.


Revisamos los datos que contiene la variable _gender_

```{r}
table(DatosCenso$gender)
```

Actualizamos para contener sólo dos valores: f - femeníno y m - masculíno

```{r}
# caso01: f - femeníno (contiene una "f")
DatosCenso$gender[grepl("[fF]+",DatosCenso$gender)]<-"f"

# caso02: m - masculino (contiene una "m")
DatosCenso$gender[grepl("[mM]+",DatosCenso$gender)]<-"m"

```

Representamos gráficamente para ver como queda la variable

```{r}
# Representamos gráficamente la variable
ggplot(DatosCenso, aes(x=gender)) + geom_bar(fill="violet") + labs(x="Gender")
```



## Normalización de los datos cuantitativos

Inspeccionar los valores de los datos cuantitativos y realizar las normalizaciones oportunas siguiendo los
criterios especificados anteriormente. Estas normalizaciones tienen como objetivo uniformizar los formatos. Si
hay valores perdidos o valores extremos, se tratarán más adelante.
Al realizar estas normalizaciones, se debe demostrar que la normalización sobre cada variable ha dado el
resultado esperado. Por lo tanto, se recomienda mostrar un fragmento del archivo de datos resultante. Para
evitar mostrar todo el conjunto de datos, se puede mostrar una parte del mismo, con las funciones head y/o
tail.
Seguid el orden de los apartados.

***

### Edad
Revisad el formato de la variable age y realizad las transformaciones oportunas según los criterios especificados
anteriormente. Si existen valores atípicos, se tratarán más adelante.

Evaluamos la variable _edad_ antes de aplicar la normalización

```{r}
 summary(DatosCenso$age)
```

Detectamos que el dataset contiene datos erróneos, el valor máximo de la variable edad es 650.
Normalizamos la variable, aplicamos la siguiente fórmula

$$ Normalización = \frac{X - min(X)}{ max(X) - min(X)} $$



```{r}

 DatosCenso$age<-(DatosCenso$age - min(DatosCenso$age)) / (max(DatosCenso$age) - min(DatosCenso$age))
 # DatosCenso$age <- (DatosCenso$age - mean(DatosCenso$age)) / sd (DatosCenso$age)
 
 # mean(DatosCenso$age)
 # sd(DatosCenso$age)
 summary(DatosCenso$age)
 
```

Obtenemos valores comprendidos entre 0 y 1. Veamos una pequeña muestra de nuestra muestra.

```{r}
 head(DatosCenso,6)
```

 
### Educación
Revisad el formato de la variable education_num y realizad las transformaciones oportunas según los criterios
especificados anteriormente. Si existen valores atípicos, se tratarán más adelante.

```{r}
summary(DatosCenso$education_num)
```

La mayoria de los valores se encuentran comprendidos entre 9 y 12, corresponde a un grado de educación de secundaria y universitaria respectivamente.

Normalizamos aplicando la fórmula vista en el apartado anterior

```{r}

 DatosCenso$education_num<-(DatosCenso$education_num - min(DatosCenso$education_num)) / (max(DatosCenso$education_num) - min(DatosCenso$education_num))

 summary(DatosCenso$education_num)
 
```

Obtenemos valores comprendidos entre 0 y 1. Veamos una pequeña muestra de nuestra muestra.

```{r}
 head(DatosCenso,6)
```

### Horas por semana
Revisad el formato de la variable hours_per_week y realizad las transformaciones oportunas según los
criterios especificados anteriormente. Si existen valores atípicos, se tratarán más adelante.

```{r}
str(DatosCenso$hours_per_week)
```
La variable es de tipo _character_ y representa el número de horas trabajadas por semana.
En primer lugar, trabajaremos para transformar la variable a un tipo de datos numérico.

```{r}
DatosCenso$hours_per_week<-gsub(" h","",DatosCenso$hours_per_week)
DatosCenso$hours_per_week<-gsub(",",".",DatosCenso$hours_per_week)
DatosCenso$hours_per_week<-as.numeric(DatosCenso$hours_per_week)
```
Normalizamos del mismo modo que las variables _Educación_ y _Edad_

```{r}
DatosCenso$hours_per_week<- (DatosCenso$hours_per_week - min(DatosCenso$hours_per_week))/(max(DatosCenso$hours_per_week)-min(DatosCenso$hours_per_week))

summary(DatosCenso$hours_per_week)
```
Obtenemos valores comprendidos entre 0 y 1. Veamos una pequeña muestra de nuestra muestra.

```{r}
 head(DatosCenso,6)
```



### Income
Revisad el formato de la variable income y realizad las transformaciones oportunas según los criterios
especificados anteriormente. Si existen valores atípicos, se tratarán más adelante.

```{r}
str(DatosCenso$income)
```
Del mismo modo que para la variable horas trabajadas por semana, nos encontramos con una variable de tipo _character_ que debemos transformar a numérica. Primero preparamos la variable, la convertimos a numérica y por último normalizamos.

Encontramos medidas expresadas en miles de euros y otras expresada en euros.

```{r}
#creamos una variable factor para la conversión de unidades de medida [euro - miles de euro]
DatosCenso$factor <-1
DatosCenso$factor[str_detect(DatosCenso$income, "Milers d'euros")]<-1000

#limpiar la variable de tipo string para transformarla en numérica
DatosCenso$income <- gsub(" Milers d'euros","",DatosCenso$income)
DatosCenso$income <- gsub(" euros","",DatosCenso$income)
DatosCenso$income <- gsub(",",".",DatosCenso$income)
DatosCenso$income <- as.numeric(DatosCenso$income)

#aplicamos la equivalencia entre unidades 
DatosCenso$income <- DatosCenso$income * DatosCenso$factor
DatosCenso$factor<-NULL

```

Normalizamos los datos

```{r}
DatosCenso$income <- (DatosCenso$income - min(DatosCenso$income))/(max(DatosCenso$income)-min(DatosCenso$income))

summary(DatosCenso$income)
```

Obtenemos valores comprendidos entre 0 y 1. Veamos una pequeña muestra de nuestra muestra.

```{r}
 head(DatosCenso,6)
```

## Valores atípicos
Revisad si hay valores atípicos en las variables age, education_num, hours_per_week y income. Si se trata
de un valor anómalo, es decir anormalmente alto o bajo, substituir su valor por NA y posteriormente, se
imputará.

***

```{r}
summary(DatosCenso[, c("age","education_num","hours_per_week","income")])
```
### Age

Según los datos resumidos de la tabla anterior, observamos una gran diferencia entre el valor del 3er cuartil y el valor máximo.

Veamos su representación gráfica
```{r}
boxplot(DatosCenso$age, col = "red")
```

En primer lugar, calculamos los límite que nos serviran para descarta los valores atípicos.
Nos basaremos en los valores del 1er y 3er cuartil y los calcularemos de la siguiente forma:

_Nivel inferior_

$$ q < Q_1 - 1.5*IQR $$
_Nivel superior_

$$ q > Q_3 + 1.5*IQR $$
Es decir, consideramos atípico aquello que se encuentra a 1.5 veces de uno de los cuartiles. Calculamos y aplicamos la transformación.

```{r}
primer_cuartil<-quantile(DatosCenso$age, prob = 0.25)
tercer_cuartil<-quantile(DatosCenso$age, prob = 0.75)
rango_intercuartilico<-IQR(DatosCenso$age)

menoresDe <- primer_cuartil - (1.5*rango_intercuartilico)
mayoresDe <- tercer_cuartil + (1.5*rango_intercuartilico)

DatosCenso$age[DatosCenso$age<menoresDe]<-NA
DatosCenso$age[DatosCenso$age>mayoresDe]<-NA

summary(DatosCenso$age)
boxplot(DatosCenso$age)
```

### education_num

Veamos la representación gráfica de la variable _education_num_
```{r}
boxplot(DatosCenso$education_num, col = "red")
```

En esta ocasión los valores atípicos los encontramos por debajo del límite inferior. Actualizaremos su valor con el valor _NA_.

Actuamos de la misma forma que con la variable _age_; calculamos los límites y descartamos valores atípicos.

```{r}

primer_cuartil<-quantile(DatosCenso$education_num, prob = 0.25)
tercer_cuartil<-quantile(DatosCenso$education_num, prob = 0.75)
rango_intercuartilico<-IQR(DatosCenso$education_num)

menoresDe <- primer_cuartil - (1.5*rango_intercuartilico)
mayoresDe <- tercer_cuartil + (1.5*rango_intercuartilico)

DatosCenso$education_num[DatosCenso$education_num<menoresDe]<-NA
DatosCenso$education_num[DatosCenso$education_num>mayoresDe]<-NA

summary(DatosCenso$education_num)
boxplot(DatosCenso$education_num)
```

### hours_per_week

Veamos la representación gráfica de la variable _hours_per_week_ y el valor de los percentiles.

```{r}
boxplot(DatosCenso$hours_per_week, col = "red")
```

Observamos _outliers_ tanto por el límite superior como por el límite inferior

```{r}

primer_cuartil<-quantile(DatosCenso$hours_per_week, prob = 0.25)
tercer_cuartil<-quantile(DatosCenso$hours_per_week, prob = 0.75)
rango_intercuartilico<-IQR(DatosCenso$hours_per_week)

menoresDe <- primer_cuartil - (1.5*rango_intercuartilico)
mayoresDe <- tercer_cuartil + (1.5*rango_intercuartilico)

DatosCenso$hours_per_week[DatosCenso$hours_per_week<menoresDe]<-NA
DatosCenso$hours_per_week[DatosCenso$hours_per_week>mayoresDe]<-NA

summary(DatosCenso$hours_per_week)
boxplot(DatosCenso$hours_per_week)
```



### income

La datos resumidos de la variable indican que el valor del tercer cuartil es 0,025 y el valor máximo 1.
Procedemos del mismo modo que en los apartados anteriores.

```{r}
boxplot(DatosCenso$income, col = "red")

# DatosCenso$income[DatosCenso$income>0.037]<-NA
# DatosCenso$income[DatosCenso$income<0.01]<-NA

primer_cuartil<-quantile(DatosCenso$income, prob = 0.25)
tercer_cuartil<-quantile(DatosCenso$income, prob = 0.75)
rango_intercuartilico<-IQR(DatosCenso$income)

menoresDe <- primer_cuartil - (1.5*rango_intercuartilico)
mayoresDe <- tercer_cuartil + (1.5*rango_intercuartilico)

DatosCenso$income[DatosCenso$income<menoresDe]<-NA
DatosCenso$income[DatosCenso$income>mayoresDe]<-NA


```

Representación gráfica de como han quedado las variables tras revisar los datos anómalos

```{r}
par(mfrow = c(1,4)) #parámetros globales para los plots --> cómo se distribuyen los gráficos (1 fila, 4 columnas)
with(DatosCenso,
     {
       boxplot(age,            col = "palegreen", main="Edad")
       boxplot(education_num,  col = "blue",      main="Educación")
       boxplot(hours_per_week, col = "pink",      main="Hora trabajadas")
       boxplot(income,         col = "orange",    main="Salario anual")
     })
```

## Imputación de valores
Buscad si existen valores perdidos en las variables cuantitativas age, education_num, hours_per_week y
income.

En caso de valores perdidos, aplicad el proceso siguiente:

* Para ‘age‘, aplicad imputación por la media aritmética.
* Para ‘income‘, aplicar imputación por la media aritmética de los registros del mismo género, es decir,
separado por género.
* En el resto de variables, aplicad imputación por vecinos más cercanos, usando la distancia de Gower,
considerando en el cómputo de los vecinos más cercanos el resto de variables cuantitativas mencionadas
en este apartado. Además, considerad que la imputación debe hacerse con registros del mismo género.
Por ejemplo, si un registro a imputar es de género "M", se debe realizar la imputación usando las
variables cuantitativas de los registros de género "M". Para realizar esta imputación, podéis usar la
función "kNN" de la librería VIM con un número de vecinos igual a 11.
Mostrad que la imputación se ha realizado correctamente, mostrando el resultado de los datos afectados por
la imputación

***

*Variable Age*

Verificamos los valores nulos para la variable _age_

```{r}
table(is.na(DatosCenso$age))
summary(DatosCenso$age)
```

Actualizamos el valor de estos casos asignando la media

```{r}

DatosCenso$age[is.na(DatosCenso$age)]<- as.integer(mean(DatosCenso$age, na.rm=TRUE))

#verificamos
table(is.na(DatosCenso$age))
```

*Variable income*

Verificamos los valores nulos para la variable _income_

```{r}
table(is.na(DatosCenso$income))
summary(DatosCenso$income)
```

Actualizamos el valor de estos casos asignando la media en función del sexo

```{r}

ValoresMedios<-DatosCenso %>%
  group_by(gender) %>%
  summarise_at(vars(income), list(valor_medio = mean), na.rm=T) 
  #mutate(income_n = coalesce(income, valor_medio)) %>% 
  #select(gender, income, income_n, valor_medio)

DatosCenso$income[is.na(DatosCenso$income) && DatosCenso$gender=="f"]<- mean(DatosCenso$income[DatosCenso$gender=="f"], na.rm = TRUE)
DatosCenso$income[is.na(DatosCenso$income) && DatosCenso$gender=="m"]<- mean(DatosCenso$income[DatosCenso$gender=="m"], na.rm = TRUE)

#DatosCenso %>% group_by(gender) %>%  mutate(income = ifelse(is.na(income), mean(income, na.rm = TRUE), income))
#DatosCenso$income[is.na(DatosCenso$income)]<- mean(DatosCenso$income, na.rm=TRUE)

#verificamos
table(is.na(DatosCenso$income))
```

Variables _education_num_ y _hours_per_week_

Examinamos del conjunto de datos qué variables nos quedan por tratar.

```{r}
colSums(is.na(DatosCenso))
```

Observamos que las variables _education_num_ y _hours_per_week_ contienen valores nulos.

En esta ocasión, tal y como solicita el enunciado, haremos una asignación teniendo en cuenta los valores de los registros más próximos. 
Para ello utlizaremos el algoritmo K-Nearest Neighbour Imputation.

```{r warning=FALSE, message=FALSE}
if (!require('VIM')) install.packages('VIM'); library(VIM, warn.conflicts = FALSE)

DatosCenso<-kNN(
  data=DatosCenso,
  variable = c("education_num","hours_per_week"),
  k = 11,
  dist_var = c("age","income"),
  catFun = group_by(gender),
  imp_var = FALSE
)
```

Una vez aplicado el algoritmo, verificamos que no quede ninguna variable con valores nulos sin tratar. 
Visualizamos un pequeño subconjunto de datos.

```{r}
colSums(is.na(DatosCenso))
head(DatosCenso)

```

## Estudio descriptivo

### Funciones de media robustas
Implementad una función en R que, dado un vector con datos numéricos, calcule la media recortada y la
media Winsor. Estas funciones se deben definir como sigue:

* media.recortada <- function( x, perc=0.05){}
* media.winsor( x, perc=0.05){}

donde x es el vector de datos y perc la fracción de los datos a recortar (por defecto, 0.05). Implementad estas
funciones en R y comprobad que funcionan correctamente

***

```{r}

#Media Recortada: Se recorta una proporción de observaciones por ambos lados de la distribución. La función de “R” para la media recortada es mean(“variable”, trim=0,2)

media.recortada <- function( x, perc=0.05)
{
  #ordenamos el vector
  x <- sort(x)

  #acotamos el vector
  a <- ceiling(length(x)*perc)
  b <- length(x) - floor(length(x)*perc)
  x <- x[c(a:b)]
  
  #calculamos la media mean(x)
  sum(x)/length(x)
}

```

```{r}
#Media Winsorizada:consiste en sustiruir los datos extremos superior e inferior por sus inmediatos anteriores. Posteriormente se calcula la media aritmética de todos los datos así actualizados

media.winsor <- function( x, perc=0.05)
{
  #ordenamos el vector
  x <- sort(x)
  
  #acotamos el vector
  a <- ceiling(length(x)*perc)
  b <- length(x) - floor(length(x)*perc)
  
  #obtenemos los valores inmediatos
  va <- x[a+1]
  vb <- x[b]
  
  #actualizamos el vector
  x[c(1:a)] <- va
  x[c(b:length(x))] <- vb
  
  #print(x)
  #calculamos la media mean(x)
  as.numeric(sum(x)/length(x))
  sum(x)/length(x)
}

```

```{r echo=FALSE, message=FALSE, warning=FALSE}

DatosEjemplo <- c(64,5,19,17,12,55,17,11,19,12,1)
paste('Verificamos la función para el vector, DatosEjemplo:')
print(DatosEjemplo)

paste('El valor de la media recortada usando la fórmula mean(DatosEjemplo, 0.3) es: ', mean(DatosEjemplo, 0.3))
paste('El valor de la media recortada usando la fórmula creada  media.recortada(DatosEjemplo,0.3) es: ', media.recortada(DatosEjemplo,0.3))
paste('El valor de la media winsor usando la fórmula creada  media.winsor(DatosEjemplo,0.3) es: ', media.winsor(DatosEjemplo,0.3))
paste('La media para ese mismo vector es: ', mean(DatosEjemplo))

```

### Estudio descriptivo de las variables cuantitativas

Realizad un estudio descriptivo de las variables cuantitativas age, education_num, hours_per_week y income.
Para ello, preparad una tabla con varias medidas de tendencia central y dispersión, robustas y no robustas.
Usad, entre otras, las funciones del apartado anterior. Presentad, asimismo gráficos donde se visualice la
distribución de los valores de estas variables cuantitativas.


```{r echo=TRUE, message=FALSE, warning=FALSE}

if (!require('FinCal')) install.packages('FinCal'); library(FinCal, warn.conflicts = FALSE)
if (!require('modeest')) install.packages('modeest'); library(modeest, warn.conflicts = FALSE)
if (!require('psych')) install.packages('psych'); library(psych, warn.conflicts = FALSE)
```

Calculamos las distinta medidas para la variable _age_

```{r}
medida <- c("media", "media recortada", "media winsor", "mediana","moda", "min", "max","1er cuartil", "2o cuartil", "3er cuartil","rango intercuartilico", "varianza", "desviación típica","coeficiente variación", "coeficiente de simetria", "coeficiente de curtosis")

age <- c(mean(DatosCenso$age), media.recortada(DatosCenso$age), media.winsor(DatosCenso$age), median(DatosCenso$age), mfv(DatosCenso$age))
age <- append(age,min(DatosCenso$age))
age <- append(age,max(DatosCenso$age))
age <- append(age,quantile(DatosCenso$age, prob = 0.25) )
age <- append(age,quantile(DatosCenso$age, prob = 0.5) )
age <- append(age,quantile(DatosCenso$age, prob = 0.75) )
age <- append(age,IQR(DatosCenso$age) )
age <- append(age,var(DatosCenso$age) )
age <- append(age,sd(DatosCenso$age) )
age <- append(age,coefficient.variation(sd=sd(DatosCenso$age), avg = mean(DatosCenso$age)))
age <- append(age,skew(DatosCenso$age))
age <- append(age,kurtosi(DatosCenso$age))
```

Hacemos lo propio para las variables _education_, _hours_per_week_ y _income_

```{r}
education <- c(mean(DatosCenso$education_num), media.recortada(DatosCenso$education_num), media.winsor(DatosCenso$education_num), median(DatosCenso$education_num),mfv(DatosCenso$education_num))
education <- append(education,min(DatosCenso$education_num))
education <- append(education,max(DatosCenso$education_num))
education <- append(education,quantile(DatosCenso$education_num, prob = 0.25) )
education <- append(education,quantile(DatosCenso$education_num, prob = 0.5) )
education <- append(education,quantile(DatosCenso$education_num, prob = 0.75) )
education <- append(education,IQR(DatosCenso$education_num) )
education <- append(education,var(DatosCenso$education_num) )
education <- append(education,sd(DatosCenso$education_num) )
education <- append(education,coefficient.variation(sd=sd(DatosCenso$education_num), avg = mean(DatosCenso$education_num)))
education <- append(education,skew(DatosCenso$education_num))
education <- append(education,kurtosi(DatosCenso$education_num))

hours_per_week <- c(mean(DatosCenso$hours_per_week), media.recortada(DatosCenso$hours_per_week), media.winsor(DatosCenso$hours_per_week), median(DatosCenso$hours_per_week),mfv(DatosCenso$hours_per_week))
hours_per_week <- append(hours_per_week,min(DatosCenso$hours_per_week))
hours_per_week <- append(hours_per_week,max(DatosCenso$hours_per_week))
hours_per_week <- append(hours_per_week,quantile(DatosCenso$hours_per_week, prob = 0.25) )
hours_per_week <- append(hours_per_week,quantile(DatosCenso$hours_per_week, prob = 0.5) )
hours_per_week <- append(hours_per_week,quantile(DatosCenso$hours_per_week, prob = 0.75) )
hours_per_week <- append(hours_per_week,IQR(DatosCenso$hours_per_week) )
hours_per_week <- append(hours_per_week,var(DatosCenso$hours_per_week) )
hours_per_week <- append(hours_per_week,sd(DatosCenso$hours_per_week) )
hours_per_week <- append(hours_per_week,coefficient.variation(sd=sd(DatosCenso$hours_per_week), avg = mean(DatosCenso$hours_per_week)))
hours_per_week <- append(hours_per_week,skew(DatosCenso$hours_per_week))
hours_per_week <- append(hours_per_week,kurtosi(DatosCenso$hours_per_week))

income <- c(mean(DatosCenso$income), media.recortada(DatosCenso$income), media.winsor(DatosCenso$income), median(DatosCenso$income),mfv(DatosCenso$income))
income <- append(income,min(DatosCenso$income))
income <- append(income,max(DatosCenso$income))
income <- append(income,quantile(DatosCenso$income, prob = 0.25) )
income <- append(income,quantile(DatosCenso$income, prob = 0.5) )
income <- append(income,quantile(DatosCenso$income, prob = 0.75) )
income <- append(income,IQR(DatosCenso$income) )
income <- append(income,var(DatosCenso$income) )
income <- append(income,sd(DatosCenso$income) )
income <- append(income,coefficient.variation(sd=sd(DatosCenso$income), avg = mean(DatosCenso$income)))
income <- append(income,skew(DatosCenso$income))
income <- append(income,kurtosi(DatosCenso$income))
```

Representamos las medidas calculadas en una tabla

```{r}

MedidasCenso <- data.frame( medida,
                  age,
                  education,
                  hours_per_week,
                  income,
                  stringsAsFactors = FALSE)

#knitr::kable(MedidasCenso, format="html")
knitr::kable(MedidasCenso, format="markdown")
```

Representamos gráficamente la distribución de las variables

```{r}
densidad_age <- density(DatosCenso$age)
densidad_education <- density(DatosCenso$education_num)
densidad_hours <- density(DatosCenso$hours_per_week)
densidad_income <- density(DatosCenso$income)

par(mfrow = c(2,2)) #parámetros globales para los plots --> cómo se distribuyen los gráficos (2 filas, 2 columnas)
with(DatosCenso,
     {
       plot(densidad_age, main="Histograma de densidad", xlab="age", ylab="Densidad", col="palegreen")
       plot(densidad_education, main="Histograma de densidad education", xlab="education_num", ylab="Densidad", col="blue")
       plot(densidad_hours, main="Histograma de densidad edad", xlab="hours_per_week", ylab="Densidad", col="pink")
       plot(densidad_income, main="Histograma de densidad edad", xlab="income", ylab="Densidad", col="orange")
     })

```


## Archivo final

Una vez realizado el preprocesamiento sobre el archivo, copiad el resultado de los datos en un archivo llamado
CensusIncome_clean.csv.

```{r}

fichero_rdo <- paste0(getwd(),"/cperezceb_CensusIncome_clean.csv")

write.csv2(DatosCenso, file = fichero_rdo, row.names = TRUE)

```

